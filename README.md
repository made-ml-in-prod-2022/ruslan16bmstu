# Домашнее задание по курсу "ML в продакшене"
## Использование
### Обучение модели
```
python3 -m ml_project.train                — по умолчанию обучается логистическая регрессия            
python3 -m ml_project.train model=busting  — обучить градиентный бустинг
python3 -m ml_project.train model=logreg   — обучить логистическую регрессию
```
### Получение предсказаний
```
python3 -m ml_project.predict artifacts/model.pkl <features path> <prediction path>
```
## Структура проекта
```
├── artifacts           <- Место сохранения обученной модели
├── raw                 <- Место сохранения датасета для обучения 
├── configs             <- Конфигурационные файлы
├── ml_project          
│   ├── data            <- Загрузка и чтение данных
│   ├── features        <- Предобработка данных
│   ├── models          <- Интструменты работы с моделью
│   ├── predict.py      <- Получение предсказаний на основе обученной модели
│   └── train.py        <- Обучение модели
├── notebooks           <- Разведочный анализ данных
├── outputs             <- Предсказанные метки
├── reports             <- Метрики
├── requirements.txt    <- Зависимости
└── tests               <- Тесты
```
## Описание проекта
В проекте реализована модель обнаружения заболевания сердца. Модель обучена на датасете [Heart Disease Cleveland UCI](https://www.kaggle.com/datasets/cherngs/heart-disease-cleveland-uci). Доступно две конфигурации для обучения: логистическая регрессия и градиентный бустинг. Для классификации, оценки результатов, разделения и трансформации данных использовалась боблиотека [sklearn](https://scikit-learn.org/stable/index.html).
# №2
## Online inference
### Локальная сборка и запуск docker-образа
```
docker build -t hw2:v1 .
docker run -p 8000:8000 hw2:v1
```
### Импорт и запуск docker-образа из dockerhub
```
docker pull ruslan16/ml_in_prod_2022:latest
docker run -p 8000:8000 ruslan16/ml_in_prod_2022:latest
```
### Запуск скрипта для работы с сервисом
```
python online_inference/client.py
```
## Размер docker-образа
1. Для опитмального размера docker-образа, необходимо сократить количество "слоев" до минимума. Это достигается путем сокращения вызовов `RUN`. В нашем случае `RUN` вызывается один раз.
2. Фактором наиболее влияющим на размер образа является выбор образа дистрибутива. Сначала я использовал `python:3.8.10` (размер образа оказался достаточно большим: 1.3 Гб). Затем я начал искать другие решения. Самый легковесный из официальных образов — `alpina`. Как я не старался, при использовании `alpina` возникали проблемы с зависимостями устанавливаемых пакетов. В итоге я остановился на `slim-buster` (Debian). Резмер образа составил 530 Мб.